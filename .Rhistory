x=reorder(labels, counts),
fill=labels)) +
geom_col(width = 0.7) +
geom_text(aes(label=counts), vjust=-0.3, size=3)+
labs(fill = lgd, title=plot_title) +
coord_flip() +
theme(legend.text=element_text(size=6))
} else if(plot_type == "bar_stack"){
plot <- data_tab %>% ggplot(aes(x = "", y = counts,
fill = labels)) +
geom_col(width = 1, color = 1) +
geom_label_repel(
aes(y = pos,
label = glue("{counts} ({percent(percentage)})"),
fill = labels),
show.legend = FALSE) +
labs(fill = lgd, title=plot_title) +
# coord_polar(theta = "y") +
theme_void() +
theme(legend.text=element_text(size=6))
}
else if (plot_type == "bar_discrete") {
plot <- data %>% ggplot(aes(y=counts, x=labels)) +
geom_col(width = 0.7) +
labs(title=plot_title,
x=x_axis, y=y_axis)
}
}else if(var_type == "cont") {
mu <- mean(df[,var_name], na.rm=TRUE)
med <- median(df[,var_name], na.rm=TRUE)
if(plot_type == "hist") {
plot <- ggplot(df, aes(x=.data[[var_name]])) +
geom_histogram(fill = "#f79e28",
col = 'black', bins=10)
}else if(plot_type == "boxplot") {
plot <- ggplot(df, aes(x=.data[[var_name]])) +
geom_boxplot(outlier.colour="red",
outlier.size=2)
}
plot <- plot +
geom_vline(xintercept = mu,
col="lightblue", lty=1, lwd = 1) +
geom_vline(xintercept = med,
col="purple", lty=2, lwd = 1) +
theme_bw() +
labs(title=plot_title,
subtitle = paste("Mean = ", round(mu, 2),
"  Median = ", med),
x=x_axis, y=y_axis)
}
return(plot)
}
generic_compare <- function(data, var_type, var1, var2,
var1_title, var2_title,
subplot_type, plot_title,
lgd_title, x_axis=NULL, y_axis=NULL,
char_remove=NULL){
var1_plot <- plot_func(data, var1, var_type, lgd = lgd_title,
var1_title, subplot_type, char_remove,
x_axis=x_axis, y_axis=y_axis)
var2_plot <- plot_func(data, var2, var_type,lgd = lgd_title,
var2_title, subplot_type, char_remove,
x_axis=x_axis, y_axis=y_axis)
if (subplot_type == "bar_simple" || subplot_type == "bar_stack") {
plot <- ggarrange(var2_plot + remove_y, var1_plot + remove_y,
ncol = 2,  nrow = 1,
common.legend = TRUE,legend="bottom")
} else {
plot <- ggarrange(var2_plot, var1_plot,
ncol = 2, nrow = 1,
common.legend = TRUE,
legend="right")
}
return(annotate_figure(plot, top = text_grob(plot_title,
color = "black", face = "bold", size = 12)))
}
compare_pre_post <- function(df_pre, df_post,
var_name, var_type, subplot_type, title,
exclude_outliers = FALSE, lgd_title,
x_axis=NULL, y_axis=NULL,
char_remove=NULL, shared_legend=TRUE) {
pre_plot <- plot_func(df_pre, var_name, var_type,
"Initial", subplot_type, lgd = lgd_title,
x_axis=x_axis, y_axis=y_axis,
char_remove=char_remove,
remove_outliers=exclude_outliers)
post_plot <- plot_func(df_post, var_name, var_type,
"Post", subplot_type, lgd = lgd_title,
x_axis=x_axis, y_axis=y_axis,
char_remove=char_remove,
remove_outliers=exclude_outliers)
if (subplot_type == "bar_simple" || subplot_type == "bar_stack") {
plot <- ggarrange(post_plot + remove_y, pre_plot + remove_y,
ncol = 2,  nrow = 1,
common.legend = shared_legend,legend="bottom")
} else {
plot <- ggarrange(post_plot, pre_plot,
ncol = 2, nrow = 1,
common.legend = shared_legend,
legend="right")
}
return(annotate_figure(plot,
top = text_grob(title, color = "black",
face = "bold", size = 12)))
}
compare_paired <- function(data, var_name, view,
lgd_title, plot_title,
char_remove=NULL){
var_pre <- as.factor(data[,paste(var_name, "pre", sep="_")])
var_post <- as.factor(data[,paste(var_name, "post", sep="_")])
labels_all <- c(unique(var_pre[is.na(var_pre) == FALSE]),
unique(var_post[is.na(var_post) == FALSE]))
x <- list(labels = unique(labels_all))
paired_df <- as.data.frame(x)
counts_post <- as.data.frame(t(table(var_post)))[,2:3]
props_post <- as.data.frame(prop.table(table(var_post)))
setnames(counts_post,
old = c('var_post','Freq'),
new = c('labels','counts_post'))
setnames(props_post,
old = c('var_post','Freq'),
new = c('labels','props_post'))
counts_pre <- as.data.frame(t(table(var_pre)))[,2:3]
props_pre <- as.data.frame(prop.table(table(var_pre)))
setnames(counts_pre,
old = c('var_pre','Freq'),
new = c('labels','counts_pre'))
setnames(props_pre,
old = c('var_pre','Freq'),
new = c('labels','props_pre'))
df_list <- list(paired_df, counts_post, counts_pre, props_pre, props_post)
merged <- df_list %>% reduce(left_join, by='labels')
merged <- merged %>% replace(is.na(.), 0)
merged$diff_counts <- merged$counts_post - merged$counts_pre
merged$diff_props <- merged$props_post - merged$props_pre
merged$count_change <- merged$diff_counts/merged$counts_pre
print(merged)
if(is.null(char_remove) == FALSE) {
merged <- merged %>% filter(!.data[['labels']] %in% char_remove)
}
# side_plot <-
count_plot <- merged %>% ggplot(aes(x = labels, y = diff_counts)) +
geom_bar(aes(fill = labels), stat="identity") +
geom_label_repel(
aes(label =
glue("{diff_counts} ({percent(count_change)})"),
fill = labels),
show.legend = FALSE) +
labs(fill = lgd_title,
y="Difference in Counts") +
theme(legend.text=element_text(size=6)) +
remove_x
prop_plot <- merged %>% ggplot(aes(x = labels, y = diff_props)) +
geom_bar(aes(fill = labels), stat="identity") +
geom_label_repel(
aes(label =
glue("{percent(diff_props)}"),
fill = labels),
show.legend = FALSE) +
labs(fill = lgd_title,
y="Difference in Proportions") +
theme(legend.text=element_text(size=6)) +
remove_x
plot <- ggarrange(count_plot, prop_plot,
ncol = 2,  nrow = 1,
common.legend = TRUE,legend="bottom")
print(annotate_figure(plot,
top = text_grob(plot_title, color = "black",
face = "bold", size = 12)))
}
violins <- function(data, var_names){
cols <- c("renewvia_id")
for(var in var_names) {
pre_name <- paste(var, "pre", sep="_")
post_name <- paste(var, "post", sep="_")
cols <- c(cols,pre_name, post_name)
}
test_paired <- data[, cols]
# Split the data in two groups
#test_paired <- outliers_removal(test_paired, pre_name)
#test_paired <- outliers_removal(test_paired, post_name)
test_paired_longer <- test_paired %>%
pivot_longer(
cols = -renewvia_id,
#names_to = "when",
# names_prefix = var_name,
# values_to = var_name,
# values_drop_na = TRUE,
# names_transform = list(var_name = as.numeric)
names_to = c(".value","when"),
names_pattern =  "(\\w+)_(pre|post)"
)
#test_paired_longer
#var_norm <- paste(var_name, "normalized", sep="_")
test_paired_longer[, var_names] <- normalize(test_paired_longer[, var_names])
df_pre <- test_paired_longer %>% filter(when == "pre")
df_post <- test_paired_longer %>% filter(when == "post")
# Plot each side and join them
vioplot(df_pre,
#horizontal=TRUE,
wex=1.2,
plotCentre = "line", # Median with a line
side = "left",     # Left side
col = "#87CEEB", ylim=c(0,1))
vioplot(df_post,
#horizontal=TRUE,
wex=1.2,
plotCentre = "line", # Median with a line
side = "right",   # Right side
col = "#f79e28",
ylim = c(0,1),
add = TRUE)  # Color for the right side
legend("topleft",
legend = c("Pre", "Post"),
fill = c("#87CEEB", "#f79e28"))
}
# Running the paired t-test
paired_testing <- function(data, var_name, test_type,
diff_type="magnitude",
plot_diff=FALSE, plt_title=NULL,
threshold=NULL,threshold_bound=NULL,
remove_outliers=FALSE, x_axis, y_axis) {
pre_name <- paste(var_name, "pre", sep="_")
post_name <- paste(var_name, "post", sep="_")
#var_pre <- data[, pre_name]
#var_post <- data[, post_name]
if(diff_type == "direction"){
data$var_diff <- ifelse(data[, post_name] > data[, pre_name], 1,
ifelse((data[, post_name] < data[, pre_name]), -1, 0))
}else if(diff_type == "magnitude") {
data$var_diff <- data[, post_name] - data[, pre_name]
}
data$diff_abs <- abs(data$var_diff)
if(remove_outliers==TRUE) {
data <- outliers_removal(data=data, var="diff_abs")
}
if(is.null(threshold) == FALSE) {
if(threshold_bound == "lower"){
data <- data %>% filter(diff_abs < threshold)
}else if(threshold_bound == "upper"){
data <- data %>% filter(diff_abs > threshold)
}
}
# Running the test
if(test_type == "wilcoxon"){
#Wilcoxon Signed-Rank Test
test <- wilcox.test(data[, pre_name], data[, post_name], paired=TRUE,
conf.int = T, correct = T, exact = F, conf.level = .95)
}else if(test_type == "sign") {
#Sign Test
test <- signtest(data$var_diff, m=0, conf.level=0.95, exact=FALSE)
} else if (test_type == "ttest") {
#Paired t-Test
test <- t.test(data[, pre_name], data[, post_name],
paired = TRUE, alternative = "two.sided")
} else if(test_type == "mcnemar") {
cross_tab <- table(data[, pre_name], data[, post_name])
print(cross_tab)
#test <- mcnemar.test(cross_tab)
test <- mcnemar.exact(cross_tab)
}
print(test)
# Visualize distribution of score differences
if(plot_diff == TRUE) {
data$var_diff <- as.integer(data$var_diff)
plot <- plot_func(df=data, var_name="var_diff", var_type="cont",
plot_title=plt_title, plot_type="hist",
x_axis=x_axis, y_axis=y_axis)
return(plot)
}
# return(test)
}
plot_reg <- function(data, feature, dependent,
remove_outliers=FALSE, which_outliers=NULL,
reg_type, vals_remove=NULL,title=NULL,
x_axis=NULL, y_axis=NULL) {
if(is.null(vals_remove) == FALSE) {
data <- data %>% filter(!.data[[dependent]] %in% vals_remove)
}
if(remove_outliers == TRUE) {
if(which_outliers=="dependent"){
data <- outliers_removal(data=data, var=dependent)
}else if(which_outliers=="feature"){
data <- outliers_removal(data=data, var=feature)
}else if(which_outliers=="all"){
temp <- outliers_removal(data=data, var=feature)
data <- outliers_removal(data=data, var=dependent)
}
}
if(reg_type == "linear") {
plot <- ggplot(data,
aes(x=.data[[feature]], y=.data[[dependent]])) +
geom_point(color= "#87CEEB") +
geom_smooth(color="#f79e28", method = "lm", se = FALSE) +
theme_classic()
} else if(reg_type == "logistic") {
plot <- ggplot(data,
aes(x=.data[[feature]], y=.data[[dependent]])) +
geom_jitter(width = 0.05, height = 0.05, color= "#87CEEB") +
#geom_point(color='blue', alpha=.5) +
geom_smooth(method = "glm", color="#f79e28",
method.args= list(binomial(link = 'logit')), se=FALSE)
theme_classic()
}else if(reg_type == "poisson") {
plot <- ggplot(data,
aes(x=.data[[feature]], y=.data[[dependent]])) +
#geom_point(color='blue', alpha=.5) +
geom_jitter(width = 0.05, height = 0.05) +
geom_smooth(method = "glm", color="#f79e28",
method.args= list(family="poisson"), se=TRUE)+
theme_classic()
}
plot <- plot + labs(title=title, y=y_axis)
return(plot)
}
ind_vars <- c("PV_Size_kWp",	"Customers",	"CAPEX_USD")
extract_p_reg <- function (modelobject) {
if (class(modelobject) != "lm") {
stop("Not an object of class 'lm' ")
}else {
f <- summary(modelobject)$fstatistic
p <- pf(f[1],f[2],f[3],lower.tail=F)
attributes(p) <- NULL
return(p)
}
}
community_reg <- function(df, col_name, dep, customer_type,
title, var_type,
calc_diff=FALSE, diff_type=NULL,
to_remove=NULL, exclude_outliers = FALSE,
outliers=NULL, y_axis=NULL) {
if (calc_diff == TRUE) {
pre_name <- paste(col_name, "pre", sep="_")
post_name <- paste(col_name, "post", sep="_")
if(diff_type == "direction"){
df$col_reg <- ifelse(df[, post_name] > df[, pre_name], 1,
ifelse((df[, post_name] < df[, pre_name]), -1, 0))
}else if(diff_type == "magnitude") {
df$col_reg <- df[, post_name] - df[, pre_name]
}
names(df)[names(df) == "community_post"] <- "community"
} else {
df$col_reg <- df[, col_name]
}
if(var_type == "categorical") {
data <- rownames_to_column(as.data.frame.matrix(
prop.table(table(
df[, "community"],
df[, "col_reg"]),
margin = 1)),
var = "community")
community_data <- merge(x=projects, y=data, by="community")
community_data$target <- as.integer(community_data[, dep]*community_data[, customer_type])
} else if(var_type == "ratio") {
data <- as.data.frame(rowsum(df[, "col_reg"],
df[, "community"], na.rm = TRUE))
data$community <- rownames(data)
community_data <- merge(x=projects, y=data, by="community")
names(community_data)[names(community_data) == "V1"] <- "target"
}
if(is.null(to_remove) == FALSE) {
#community_data <- community_data[!grepl(to_remove,data$target),]
community_data <- community_data %>% filter(!.data[["target"]] %in% to_remove)
}
print(community_data)
target_dist_data <- outliers_removal(data=community_data, var="target")
dist <- plot_func(df=target_dist_data, var_name="target", var_type="cont",
plot_title="Dependent Variable Boxplot", plot_type="boxplot",
char_remove=NULL,
remove_outliers = FALSE,
x_axis=NULL, y_axis=NULL)
lst <- list(dist)
lst_sig <- list()
for(ind in ind_vars) {
print(ind)
if(exclude_outliers == TRUE) {
community_data <- outliers_removal(data=community_data, var=ind)
}
p <- plot_reg(data=community_data, feature=ind,
dependent="target", reg_type="linear",
# remove_outliers = exclude_outliers,
# which_outliers = outliers,
y_axis=y_axis)
lst <- append(lst, list(p))
pearson_test <- cor.test(community_data[, "target"],
community_data[,ind],
method="pearson")
print(pearson_test)
lm <- lm(community_data[,"target"] ~ community_data[,ind])
details <- summary(lm)
f <- summary(lm)$fstatistic
p_val <- pf(f[1],f[2],f[3],lower.tail=F)
attributes(p_val) <- NULL
if(p_val < 0.05) {
lst_sig <- append(lst_sig, list(p))
}
print(details)
print(confint(lm, level=0.95))
}
plot <- ggarrange(plotlist = lst,
ncol = 2, nrow = 2,
common.legend = TRUE,
legend="right")
annotate_figure(plot, top = text_grob(title,
color = "black", face = "bold", size = 12))
}
consumption_reg <- function(df, dep, ind, title, reg_type,
calc_diff=FALSE, diff_type=NULL,
exclude_outliers = FALSE,
outliers=NULL, to_remove=NULL,
x_axis=NULL, y_axis=NULL,
normalize=FALSE,
threshold=NULL,
threshold_bound=NULL,
log_direction=NULL) {
if (calc_diff == TRUE) {
pre_name <- paste(dep, "pre", sep="_")
post_name <- paste(dep, "post", sep="_")
if(diff_type == "direction"){
df$col_reg <- ifelse(df[, post_name] > df[, pre_name], 1,
ifelse((df[, post_name] < df[, pre_name]), -1, 0))
}else if(diff_type == "magnitude") {
df$col_reg <- df[, post_name] - df[, pre_name]
}
} else {
df$col_reg <- df[, dep]
}
if(is.null(threshold) == FALSE) {
if(threshold_bound == "lower"){
df <- df %>% filter(col_reg < threshold)
}else if(threshold_bound == "higher"){
df <- df %>% filter(col_reg > threshold)
}
}
if(normalize==TRUE) {
df$col_reg <- normalize(df$col_reg)
}
print(dim(df))
print(head(df[, c(ind, "col_reg")]))
if(reg_type == "linear") {
model <- lm(df$col_reg ~ df[, ind])
print(summary(model))
print(confint(model, level=0.95))
p <- plot_reg(data=df, feature=ind,
dependent="col_reg", reg_type="linear",
remove_outliers=exclude_outliers,
which_outliers = outliers,
vals_remove=to_remove,
title=title, x_axi=x_axis, y_axis=y_axis)
test <- cor.test(df$col_reg, df[, ind],
method="pearson")
print(test)
} else if(reg_type == "logistic") {
#if(calc_diff == TRUE) {
if(log_direction == 1) {
df <- df %>% filter(col_reg >= 0)
}else if(log_direction == -1) {
df <- df %>% filter(col_reg <= 0)
df$col_reg <- ifelse(df$col_reg == -1, 1, 0)
}
model <- glm(df$col_reg ~ df[, ind],
family="binomial")
print(summary(model))
print(confint(model, level=0.95))
p <- plot_reg(data=df, feature=ind,
dependent="col_reg", reg_type="logistic",
remove_outliers=exclude_outliers,
which_outliers = outliers,
vals_remove=to_remove,
title=title, x_axi=x_axis, y_axis=y_axis)
#test <- wald.test(Sigma = vcov(model), b = coef(model), Terms = 1)
test <- anova(model,test=c("LR"))
print(test)
}else if(reg_type == "poisson") {
model <- glm(df$col_reg ~ df[, ind],
family="poisson")
print(summary(model))
print(confint(model, level=0.95))
p <- plot_reg(data=df, feature=ind,
dependent="col_reg", reg_type="poisson",
remove_outliers=exclude_outliers,
which_outliers = outliers,
vals_remove=to_remove,
title=title, x_axi=x_axis, y_axis=y_axis)
#test <- wald.test(Sigma = vcov(model), b = coef(model), Terms = 1)
print(test)
}
return(p)
}
# rg <- preProcess(as.data.frame(paired_enc$kerosene_lamps_count_post),
#                    method=c("range"))
#
# temp <- predict(rg, as.data.frame(paired_enc$kerosene_lamps_count_post))
# temp$consumption <- paired_enc$avg_mon_consumption_period
# paired_enc$test <- log(paired_enc$water_cost_post)
# ggplot(paired_enc,
#         aes(x=avg_mon_consumption_period,
#             y=test)) +
#         geom_point(color='blue') +
#           geom_smooth(color='red', method = "lm", se = TRUE) +
#         theme_classic()
## What was the gender breakdown of survey respondents, pre and post?
# Unpaired
compare_pre_post(df_pre=initial_pre, df_post=post_clean,
var_name="gender", var_type="non_cont",
lgd_title ="Gender",
subplot_type="bar_simple", title="Unpaired: Gender Breakdown")
# Paired
# plot_func(df=paired_clean,
#           var_name="gender_post", var_type="non_cont", lgd = "Gender",
#           plot_title="Paired: Gender Breakdown",
#           plot_type="bar_simple")
